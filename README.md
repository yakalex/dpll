# Алгоритм DPLL
## Сборка
`make dpll`
## Запуск
`./dpll path_to_file`

`path_to_file` - путь к файлу в формате [DIMACS](https://www.cs.ubc.ca/~hoos/SATLIB/benchm.html)
## Особенности реализации
* Только правило распространения единицы
* Рекурсия заменена на стек проверяемых формул
* Клаузы - множества литералов
* Для каждой формулы хранятся:
  * Вектор указателей на клаузы. Доступ к клаузам осуществляется по индексам за O(1). Удаление клаузы из вектора также производится за O(1): указатель принимает значение `nullptr`
  * Сопоставление литерал - множество индексов клауз, в которых присутствует литерал. Доступ к множеству осуществляется по индексу литерала за O(1). Удаление индекса из множество производится за O(log(m)), где m - число клауз, в которых присутствует литерал
  * Вспомогательное множество индексов единичных клауз
  * Флаг, указывающий, содержит ли формула пустую клаузу
* При копировании формулы клаузы и множества индексов клауз копируются лениво: в действительности копирование производится только в момент их изменения
* Выбор литерала при разделении формулы производится по следующему принципу: выбирается клауза,содержащая наименьшее число литералов. Из этой клаузы берется литерал с наименьшим индексом.
## Результаты
Тестировалось на формуле **hanoi4.cnf**:
* Время работы ~13c (один поток, intel core i5 8250U)
* Пиковое потребление памяти ~3МБ
